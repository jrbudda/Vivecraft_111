--- a/net/minecraft/client/renderer/ItemRenderer.java
+++ b/net/minecraft/client/renderer/ItemRenderer.java
@@ -1,12 +1,20 @@
 package net.minecraft.client.renderer;
 
+import javax.annotation.Nullable;
+
 import com.google.common.base.Objects;
+import com.mojang.realmsclient.util.RealmsTasks.SwitchMinigameTask;
+
 import net.minecraft.block.Block;
+import net.minecraft.block.BlockLiquid;
 import net.minecraft.block.material.Material;
+import net.minecraft.block.material.MaterialLiquid;
 import net.minecraft.block.state.IBlockState;
 import net.minecraft.client.Minecraft;
+import net.minecraft.client.Minecraft.renderPass;
 import net.minecraft.client.entity.AbstractClientPlayer;
 import net.minecraft.client.entity.EntityPlayerSP;
+import net.minecraft.client.gui.ScaledResolution;
 import net.minecraft.client.renderer.block.model.ItemCameraTransforms;
 import net.minecraft.client.renderer.entity.Render;
 import net.minecraft.client.renderer.entity.RenderManager;
@@ -15,11 +23,25 @@
 import net.minecraft.client.renderer.texture.TextureMap;
 import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
 import net.minecraft.entity.EntityLivingBase;
+import net.minecraft.entity.item.EntityBoat;
 import net.minecraft.entity.player.EntityPlayer;
+import net.minecraft.init.Blocks;
 import net.minecraft.init.Items;
+import net.minecraft.init.MobEffects;
 import net.minecraft.item.Item;
+import net.minecraft.item.ItemArrow;
+import net.minecraft.item.ItemBlock;
+import net.minecraft.item.ItemBow;
+import net.minecraft.item.ItemCarrotOnAStick;
+import net.minecraft.item.ItemFishingRod;
+import net.minecraft.item.ItemFlintAndSteel;
+import net.minecraft.item.ItemHoe;
 import net.minecraft.item.ItemMap;
+import net.minecraft.item.ItemShears;
+import net.minecraft.item.ItemShield;
 import net.minecraft.item.ItemStack;
+import net.minecraft.item.ItemSword;
+import net.minecraft.item.ItemTool;
 import net.minecraft.src.Config;
 import net.minecraft.src.DynamicLights;
 import net.minecraft.src.Reflector;
@@ -30,9 +52,16 @@
 import net.minecraft.util.ResourceLocation;
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.util.math.MathHelper;
+import net.minecraft.util.math.Vec3d;
 import net.minecraft.world.storage.MapData;
 import shadersmod.client.Shaders;
 
+import com.mtbs3d.minecrift.provider.MCOpenVR;
+import com.mtbs3d.minecrift.render.OpenGLdebugging;
+import com.mtbs3d.minecrift.render.RenderVRPlayer;
+
+import de.fruitfly.ovr.structs.Vector3f;
+
 public class ItemRenderer
 {
     private static final ResourceLocation RES_MAP_BACKGROUND = new ResourceLocation("textures/map/map_background.png");
@@ -48,21 +77,34 @@
     private float prevEquippedProgressOffHand;
     private final RenderManager renderManager;
     private final RenderItem itemRenderer;
-
+    private RenderVRPlayer myRenderVRPlayer;
+    
+    public float getEquipProgress(EnumHand hand, float partialTicks){
+    	if(hand == EnumHand.MAIN_HAND)
+    		return 1.0f- (this.prevEquippedProgressMainHand + (this.equippedProgressMainHand - this.prevEquippedProgressMainHand) * partialTicks);
+    	else
+    		return 1.0F - (this.prevEquippedProgressOffHand + (this.equippedProgressOffHand - this.prevEquippedProgressOffHand) * partialTicks);
+    }
+    
     public ItemRenderer(Minecraft mcIn)
     {
         this.mc = mcIn;
         this.renderManager = mcIn.getRenderManager();
         this.itemRenderer = mcIn.getRenderItem();
+        myRenderVRPlayer = new RenderVRPlayer(this.renderManager);
     }
 
     public void renderItem(EntityLivingBase entityIn, ItemStack heldStack, ItemCameraTransforms.TransformType transform)
     {
-        this.renderItemSide(entityIn, heldStack, transform, false);
+        this.renderItemSide(0,entityIn, heldStack, transform, false);
     }
-
-    public void renderItemSide(EntityLivingBase entitylivingbaseIn, ItemStack heldStack, ItemCameraTransforms.TransformType transform, boolean leftHanded)
+    
+    public void renderItemSide(EntityLivingBase entityIn, ItemStack heldStack, ItemCameraTransforms.TransformType transform, boolean rightSide)
     {
+        this.renderItemSide(0,entityIn, heldStack, transform, rightSide);
+    }
+
+    public void renderItemSide(float par1, EntityLivingBase entitylivingbaseIn, ItemStack heldStack, ItemCameraTransforms.TransformType transform, boolean rightSide)    {
         if (!heldStack.isEmpty())
         {
             Item item = heldStack.getItem();
@@ -70,17 +112,17 @@
             GlStateManager.pushMatrix();
             boolean flag = this.itemRenderer.shouldRenderItemIn3D(heldStack) && block.getBlockLayer() == BlockRenderLayer.TRANSLUCENT;
 
-            if (flag)
-            {
-                GlStateManager.depthMask(false);
-            }
-
-            this.itemRenderer.renderItem(heldStack, entitylivingbaseIn, transform, leftHanded);
-
-            if (flag)
-            {
-                GlStateManager.depthMask(true);
-            }
+//            if (flag)
+//            {
+//                GlStateManager.depthMask(false);
+//            }
+
+            this.itemRenderer.renderItem(par1, heldStack, entitylivingbaseIn, transform, rightSide);
+
+//            if (flag)
+//            {
+//                GlStateManager.depthMask(true);
+//            }
 
             GlStateManager.popMatrix();
         }
@@ -98,7 +140,7 @@
         GlStateManager.popMatrix();
     }
 
-    private void setLightmap()
+    void setLightmap()
     {
         AbstractClientPlayer abstractclientplayer = this.mc.player;
         int i = this.mc.world.getCombinedLight(new BlockPos(abstractclientplayer.posX, abstractclientplayer.posY + (double)abstractclientplayer.getEyeHeight(), abstractclientplayer.posZ), 0);
@@ -113,6 +155,7 @@
         OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, f, f1);
     }
 
+    //unused
     private void rotateArm(float p_187458_1_)
     {
         EntityPlayerSP entityplayersp = this.mc.player;
@@ -133,6 +176,7 @@
         return f;
     }
 
+    //for map only
     private void renderArms()
     {
         if (!this.mc.player.isInvisible())
@@ -147,6 +191,7 @@
         }
     }
 
+    //for map only
     private void renderArm(EnumHandSide p_187455_1_)
     {
         this.mc.getTextureManager().bindTexture(this.mc.player.getLocationSkin());
@@ -174,27 +219,29 @@
     private void renderMapFirstPersonSide(float p_187465_1_, EnumHandSide p_187465_2_, float p_187465_3_, ItemStack p_187465_4_)
     {
         float f = p_187465_2_ == EnumHandSide.RIGHT ? 1.0F : -1.0F;
-        GlStateManager.translate(f * 0.125F, -0.125F, 0.0F);
 
         if (!this.mc.player.isInvisible())
         {
-            GlStateManager.pushMatrix();
-            GlStateManager.rotate(f * 10.0F, 0.0F, 0.0F, 1.0F);
-            this.renderArmFirstPerson(p_187465_1_, p_187465_3_, p_187465_2_);
-            GlStateManager.popMatrix();
+//            GlStateManager.pushMatrix();
+//            GlStateManager.rotate(f * 10.0F, 0.0F, 0.0F, 1.0F);
+//            this.renderArmFirstPerson(p_187465_1_, p_187465_3_, p_187465_2_);
+//            GlStateManager.popMatrix();
         }
 
         GlStateManager.pushMatrix();
-        GlStateManager.translate(f * 0.51F, -0.08F + p_187465_1_ * -1.2F, -0.75F);
-        float f1 = MathHelper.sqrt(p_187465_3_);
-        float f2 = MathHelper.sin(f1 * (float)Math.PI);
-        float f3 = -0.5F * f2;
-        float f4 = 0.4F * MathHelper.sin(f1 * ((float)Math.PI * 2F));
-        float f5 = -0.3F * MathHelper.sin(p_187465_3_ * (float)Math.PI);
-        GlStateManager.translate(f * f3, f4 - 0.3F * f2, f5);
-        GlStateManager.rotate(f2 * -45.0F, 1.0F, 0.0F, 0.0F);
-        GlStateManager.rotate(f * f2 * -30.0F, 0.0F, 1.0F, 0.0F);
-        this.renderMapFirstPerson(p_187465_4_);
+        GlStateManager.translate(-f * 0F, 0.225F, -0.1F);
+        GlStateManager.rotate(-30.0F, 1.0F, 0.0F, 0.0F);
+        GlStateManager.rotate(-30.0F*f, 0.0F, 1.0F, 0.0F);
+	      //  GlStateManager.translate(f * 0.51F, -0.08F + p_187465_1_ * -1.2F, -0.75F);
+	        float f1 = MathHelper.sqrt(p_187465_3_);
+	        float f2 = MathHelper.sin(f1 * (float)Math.PI);
+	        float f3 = -0.5F * f2;
+	        float f4 = 0.4F * MathHelper.sin(f1 * ((float)Math.PI * 2F));
+	        float f5 = -0.3F * MathHelper.sin(p_187465_3_ * (float)Math.PI);
+//	       GlStateManager.translate(f * f3, f4 - 0.3F * f2, f5);
+//	        GlStateManager.rotate(f2 * -45.0F, 1.0F, 0.0F, 0.0F);
+//	       GlStateManager.rotate(f * f2 * -30.0F, 0.0F, 1.0F, 0.0F);
+	        this.renderMapFirstPerson(p_187465_4_);
         GlStateManager.popMatrix();
     }
 
@@ -203,14 +250,17 @@
         float f = MathHelper.sqrt(p_187463_3_);
         float f1 = -0.2F * MathHelper.sin(p_187463_3_ * (float)Math.PI);
         float f2 = -0.4F * MathHelper.sin(f * (float)Math.PI);
-        GlStateManager.translate(0.0F, -f1 / 2.0F, f2);
+        //GlStateManager.translate(0.0F, -f1 / 2.0F, f2);
         float f3 = this.getMapAngleFromPitch(p_187463_1_);
-        GlStateManager.translate(0.0F, 0.04F + p_187463_2_ * -1.2F + f3 * -0.5F, -0.72F);
-        GlStateManager.rotate(f3 * -85.0F, 1.0F, 0.0F, 0.0F);
-        this.renderArms();
+      //  GlStateManager.translate(0.0F, 0.04F + p_187463_2_ * -1.2F + f3 * -0.5F, -0.72F);
+        //GlStateManager.rotate(f3 * -85.0F, 1.0F, 0.0F, 0.0F);
+       // this.renderArms();
         float f4 = MathHelper.sin(f * (float)Math.PI);
-        GlStateManager.rotate(f4 * 20.0F, 1.0F, 0.0F, 0.0F);
-        GlStateManager.scale(2.0F, 2.0F, 2.0F);
+       // GlStateManager.rotate(f4 * 20.0F, 1.0F, 0.0F, 0.0F);
+        GlStateManager.translate(-f * 0F, 0.225F, -0.5F);
+        GlStateManager.scale(1.5F, 1.5F, 1.5F);
+        GlStateManager.rotate(-30.0F, 1.0F, 0.0F, 0.0F);
+        GlStateManager.rotate(-30.0F*f, 0.0F, 1.0F, 0.0F);
         this.renderMapFirstPerson(this.itemStackMainHand);
     }
 
@@ -241,100 +291,132 @@
         GlStateManager.enableLighting();
     }
 
-    private void renderArmFirstPerson(float p_187456_1_, float p_187456_2_, EnumHandSide p_187456_3_)
-    {
-        boolean flag = p_187456_3_ != EnumHandSide.LEFT;
+    private void renderArmFirstPerson(float equipProgress, float swingProgress, EnumHandSide side)
+ { //render arm
+    	
+        boolean flag = side != EnumHandSide.LEFT;       
         float f = flag ? 1.0F : -1.0F;
-        float f1 = MathHelper.sqrt(p_187456_2_);
-        float f2 = -0.3F * MathHelper.sin(f1 * (float)Math.PI);
-        float f3 = 0.4F * MathHelper.sin(f1 * ((float)Math.PI * 2F));
-        float f4 = -0.4F * MathHelper.sin(p_187456_2_ * (float)Math.PI);
-        GlStateManager.translate(f * (f2 + 0.64000005F), f3 + -0.6F + p_187456_1_ * -0.6F, f4 + -0.71999997F);
-        GlStateManager.rotate(f * 45.0F, 0.0F, 1.0F, 0.0F);
-        float f5 = MathHelper.sin(p_187456_2_ * p_187456_2_ * (float)Math.PI);
-        float f6 = MathHelper.sin(f1 * (float)Math.PI);
-        GlStateManager.rotate(f * f6 * 70.0F, 0.0F, 1.0F, 0.0F);
-        GlStateManager.rotate(f * f5 * -20.0F, 0.0F, 0.0F, 1.0F);
         AbstractClientPlayer abstractclientplayer = this.mc.player;
         this.mc.getTextureManager().bindTexture(abstractclientplayer.getLocationSkin());
-        GlStateManager.translate(f * -1.0F, 3.6F, 3.5F);
-        GlStateManager.rotate(f * 120.0F, 0.0F, 0.0F, 1.0F);
-        GlStateManager.rotate(200.0F, 1.0F, 0.0F, 0.0F);
-        GlStateManager.rotate(f * -135.0F, 0.0F, 1.0F, 0.0F);
-        GlStateManager.translate(f * 5.6F, 0.0F, 0.0F);
-        RenderPlayer renderplayer = (RenderPlayer)this.renderManager.getEntityRenderObject(abstractclientplayer);
-        GlStateManager.disableCull();
-
-        if (flag)
-        {
-            renderplayer.renderRightArm(abstractclientplayer);
-        }
-        else
-        {
-            renderplayer.renderLeftArm(abstractclientplayer);
-        }
-
+        
+//        float f1 = MathHelper.sqrt_float(swingProgress);
+//        float f2 = -0.3F * MathHelper.sin(f1 * (float)Math.PI);
+//        float f3 = 0.4F * MathHelper.sin(f1 * ((float)Math.PI * 2F));
+//        float f4 = -0.4F * MathHelper.sin(swingProgress * (float)Math.PI);
+//        GlStateManager.translate(f * (f2 + 0.64000005F), f3 + -0.6F + equipProgress * -0.6F, f4 + -0.71999997F);
+//        GlStateManager.rotate(f * 45.0F, 0.0F, 1.0F, 0.0F);
+//        float f5 = MathHelper.sin(swingProgress * swingProgress * (float)Math.PI);
+//        float f6 = MathHelper.sin(f1 * (float)Math.PI);
+//        GlStateManager.rotate(f * f6 * 70.0F, 0.0F, 1.0F, 0.0F);
+//        GlStateManager.rotate(f * f5 * -20.0F, 0.0F, 0.0F, 1.0F);
+//        GlStateManager.translate(f * -1.0F, 3.6F, 3.5F);
+//        GlStateManager.rotate(f * 120.0F, 0.0F, 0.0F, 1.0F);
+//        GlStateManager.rotate(200.0F, 1.0F, 0.0F, 0.0F);
+//        GlStateManager.rotate(f * -135.0F, 0.0F, 1.0F, 0.0F);
+//        GlStateManager.translate(f * 5.6F, 0.0F, 0.0F);
+     //VIVE this is all thats needed to align hands with controllers. 
+        //TODO: Animation.
+        
+        GlStateManager.pushMatrix();
+        
+			this.transformFirstPerson(side, swingProgress);
+        
+        	GlStateManager.scale(0.4f, 0.4F, 0.4F);
+        	GlStateManager.translate(0.375*-f, 0, .75);
+	        GlStateManager.rotate(-90, 1, 0,0);
+	        GlStateManager.disableCull();
+	        
+	        GlStateManager.rotate(180, 0, 1, 0);	
+	        
+	        if (flag)
+	        {
+	        	myRenderVRPlayer.renderRightArm(abstractclientplayer);
+	        }
+	        else
+	        {
+	        	myRenderVRPlayer.renderLeftArm(abstractclientplayer);
+	        }
+        GlStateManager.popMatrix();
         GlStateManager.enableCull();
     }
 
-    private void transformEatFirstPerson(float p_187454_1_, EnumHandSide p_187454_2_, ItemStack p_187454_3_)
+    //better name would be doEatAnimation
+    private void transformEatFirstPerson(float progress, EnumHandSide side, ItemStack item)
     {
-        float f = (float)this.mc.player.getItemInUseCount() - p_187454_1_ + 1.0F;
-        float f1 = f / (float)p_187454_3_.getMaxItemUseDuration();
+        float f = (float)this.mc.player.getItemInUseCount() - progress + 1.0F;
+        float f1 = f / (float)item.getMaxItemUseDuration();
 
         if (f1 < 0.8F)
         {
             float f2 = MathHelper.abs(MathHelper.cos(f / 4.0F * (float)Math.PI) * 0.1F);
-            GlStateManager.translate(0.0F, f2, 0.0F);
+      //      GlStateManager.translate(0.0F, f2, 0.0F);
         }
 
-        float f3 = 1.0F - (float)Math.pow((double)f1, 27.0D);
-        int i = p_187454_2_ == EnumHandSide.RIGHT ? 1 : -1;
-        GlStateManager.translate(f3 * 0.6F * (float)i, f3 * -0.5F, f3 * 0.0F);
-        GlStateManager.rotate((float)i * f3 * 90.0F, 0.0F, 1.0F, 0.0F);
-        GlStateManager.rotate(f3 * 10.0F, 1.0F, 0.0F, 0.0F);
-        GlStateManager.rotate((float)i * f3 * 30.0F, 0.0F, 0.0F, 1.0F);
+	    if(!Minecraft.getMinecraft().autoFood.isEating()) {
+		    float f3 = 1.0F - (float) Math.pow((double) f1, 27.0D);
+		    int i = side == EnumHandSide.RIGHT ? 1 : -1;
+		    //  GlStateManager.translate(f3 * 0.6F * (float)i, f3 * -0.5F, f3 * 0.0F);
+		    GlStateManager.rotate((float) i * f3 * 90.0F, 0.0F, 1.0F, 0.0F);
+		    GlStateManager.rotate(f3 * 10.0F, 1.0F, 0.0F, 0.0F);
+		    GlStateManager.rotate((float) i * f3 * 30.0F, 0.0F, 0.0F, 1.0F);
+	    } else { //OM NOM NOM NOM
+			long t = this.mc.player.getItemInUseCount();
+			GlStateManager.translate(0,0.006*Math.sin(t), 0);
+	    }
+    }
+
+    //better name would be doSwingItemAnimation
+    private void transformFirstPerson(EnumHandSide side, float swingprogress)
+    {
+    	if(swingprogress == 0) return;
+    	//VIVE TODO: SOMETHING
+    	int i = side == EnumHandSide.RIGHT ? 1 : -1;
+    	float f = MathHelper.sin(swingprogress * swingprogress * (float)Math.PI);
+    	//  GlStateManager.rotate((float)i * (45.0F + f * -20.0F), 0.0F, 1.0F, 0.0F);
+    	float f1 = 0.5f * MathHelper.sin(MathHelper.sqrt(swingprogress) * (float)Math.PI);
+    	float 	f2= MathHelper.sin((float) (swingprogress *3*Math.PI));
+    	if(swingprogress > 0.5) {
+    		f2= MathHelper.sin((float) (swingprogress *Math.PI + Math.PI));
+    	}
+    	GlStateManager.translate(0,0,-f1);
+    	//        GlStateManager.rotate((float)i * f1 * -20.0F, 0.0F, 0.0F, 1.0F);
+    	GlStateManager.rotate((f2) * 45.0F  , 1.0F, 0.0F, 0.0F);
+    	//        GlStateManager.rotate((float)i * -45.0F, 0.0F, 1.0F, 0.0F);
+    }
+
+    //better name would be doEquipItemAnimation
+    private void transformSideFirstPerson(EnumHandSide side, float equippingprogress)
+    {
+    	//VIVE NOOP
+//        int i = side == EnumHandSide.RIGHT ? 1 : -1;
+//        GlStateManager.translate((float)i * 0.56F, -0.52F + equippingprogress * -0.6F, -0.72F);
     }
 
-    private void transformFirstPerson(EnumHandSide p_187453_1_, float p_187453_2_)
-    {
-        int i = p_187453_1_ == EnumHandSide.RIGHT ? 1 : -1;
-        float f = MathHelper.sin(p_187453_2_ * p_187453_2_ * (float)Math.PI);
-        GlStateManager.rotate((float)i * (45.0F + f * -20.0F), 0.0F, 1.0F, 0.0F);
-        float f1 = MathHelper.sin(MathHelper.sqrt(p_187453_2_) * (float)Math.PI);
-        GlStateManager.rotate((float)i * f1 * -20.0F, 0.0F, 0.0F, 1.0F);
-        GlStateManager.rotate(f1 * -80.0F, 1.0F, 0.0F, 0.0F);
-        GlStateManager.rotate((float)i * -45.0F, 0.0F, 1.0F, 0.0F);
-    }
-
-    private void transformSideFirstPerson(EnumHandSide p_187459_1_, float p_187459_2_)
-    {
-        int i = p_187459_1_ == EnumHandSide.RIGHT ? 1 : -1;
-        GlStateManager.translate((float)i * 0.56F, -0.52F + p_187459_2_ * -0.6F, -0.72F);
-    }
 
     /**
      * Renders the active item in the player's hand when in first person mode.
      */
+    
+    //VIVE have to skip this method, go straight to each hand
     public void renderItemInFirstPerson(float partialTicks)
     {
-        AbstractClientPlayer abstractclientplayer = this.mc.player;
-        float f = abstractclientplayer.getSwingProgress(partialTicks);
-        EnumHand enumhand = (EnumHand)Objects.firstNonNull(abstractclientplayer.swingingHand, EnumHand.MAIN_HAND);
-        float f1 = abstractclientplayer.prevRotationPitch + (abstractclientplayer.rotationPitch - abstractclientplayer.prevRotationPitch) * partialTicks;
-        float f2 = abstractclientplayer.prevRotationYaw + (abstractclientplayer.rotationYaw - abstractclientplayer.prevRotationYaw) * partialTicks;
-        boolean flag = true;
-        boolean flag1 = true;
+        AbstractClientPlayer player = this.mc.player;
+        float swingprogress = player.getSwingProgress(partialTicks);
+        EnumHand hand = (EnumHand)Objects.firstNonNull(player.swingingHand, EnumHand.MAIN_HAND);
+        float f1 = player.prevRotationPitch + (player.rotationPitch - player.prevRotationPitch) * partialTicks;
+        float f2 = player.prevRotationYaw + (player.rotationYaw - player.prevRotationYaw) * partialTicks;
+        boolean doRighthand = true;
+        boolean doLeftHand = true;
 
-        if (abstractclientplayer.isHandActive())
+        if (player.isHandActive())
         {
-            ItemStack itemstack = abstractclientplayer.getActiveItemStack();
+            ItemStack itemstack = player.getActiveItemStack();
 
             if (itemstack != null && itemstack.getItem() == Items.BOW)
-            {
-                EnumHand enumhand1 = abstractclientplayer.getActiveHand();
-                flag = enumhand1 == EnumHand.MAIN_HAND;
-                flag1 = !flag;
+            {//bow mode
+                EnumHand enumhand1 = player.getActiveHand();
+                doRighthand = enumhand1 == EnumHand.MAIN_HAND;
+                doLeftHand = !doRighthand;
             }
         }
 
@@ -343,200 +425,529 @@
         this.rotateArm(partialTicks);
         GlStateManager.enableRescaleNormal();
 
-        if (flag)
+        if (doRighthand)
         {
-            float f3 = enumhand == EnumHand.MAIN_HAND ? f : 0.0F;
+            float f3 = hand == EnumHand.MAIN_HAND ? swingprogress : 0.0F;
             float f5 = 1.0F - (this.prevEquippedProgressMainHand + (this.equippedProgressMainHand - this.prevEquippedProgressMainHand) * partialTicks);
-
-            if (!Reflector.ForgeHooksClient_renderSpecificFirstPersonHand.exists() || !Reflector.callBoolean(Reflector.ForgeHooksClient_renderSpecificFirstPersonHand, new Object[] {EnumHand.MAIN_HAND, Float.valueOf(partialTicks), Float.valueOf(f1), Float.valueOf(f3), Float.valueOf(f5), this.itemStackMainHand}))
-            {
-                this.renderItemInFirstPerson(abstractclientplayer, partialTicks, f1, EnumHand.MAIN_HAND, f3, this.itemStackMainHand, f5);
-            }
+            this.renderItemInFirstPerson(player, partialTicks, f1, EnumHand.MAIN_HAND, f3, this.itemStackMainHand, f5);
         }
 
-        if (flag1)
+        if (doLeftHand)
         {
-            float f4 = enumhand == EnumHand.OFF_HAND ? f : 0.0F;
+            float f4 = hand == EnumHand.OFF_HAND ? swingprogress : 0.0F;
             float f6 = 1.0F - (this.prevEquippedProgressOffHand + (this.equippedProgressOffHand - this.prevEquippedProgressOffHand) * partialTicks);
-
-            if (!Reflector.ForgeHooksClient_renderSpecificFirstPersonHand.exists() || !Reflector.callBoolean(Reflector.ForgeHooksClient_renderSpecificFirstPersonHand, new Object[] {EnumHand.OFF_HAND, Float.valueOf(partialTicks), Float.valueOf(f1), Float.valueOf(f4), Float.valueOf(f6), this.itemStackOffHand}))
-            {
-                this.renderItemInFirstPerson(abstractclientplayer, partialTicks, f1, EnumHand.OFF_HAND, f4, this.itemStackOffHand, f6);
-            }
+            this.renderItemInFirstPerson(player, partialTicks, f1, EnumHand.OFF_HAND, f4, this.itemStackOffHand, f6);
         }
 
         GlStateManager.disableRescaleNormal();
         RenderHelper.disableStandardItemLighting();
     }
 
-    public void renderItemInFirstPerson(AbstractClientPlayer p_187457_1_, float p_187457_2_, float p_187457_3_, EnumHand p_187457_4_, float p_187457_5_, ItemStack p_187457_6_, float p_187457_7_)
+    public void renderItemInFirstPerson(AbstractClientPlayer player, float partialTicks, float bodyPitch, EnumHand hand, float swingProgress, @Nullable ItemStack itemstack, float equippingprogress)
     {
-        boolean flag = p_187457_4_ == EnumHand.MAIN_HAND;
-        EnumHandSide enumhandside = flag ? p_187457_1_.getPrimaryHand() : p_187457_1_.getPrimaryHand().opposite();
-        GlStateManager.pushMatrix();
-
-        if (p_187457_6_.isEmpty())
-        {
-            if (flag && !p_187457_1_.isInvisible())
-            {
-                this.renderArmFirstPerson(p_187457_7_, p_187457_5_, enumhandside);
-            }
-        }
-        else if (p_187457_6_.getItem() instanceof ItemMap)
-        {
-            if (flag && this.itemStackOffHand.isEmpty())
-            {
-                this.renderMapFirstPerson(p_187457_3_, p_187457_7_, p_187457_5_);
-            }
-            else
-            {
-                this.renderMapFirstPersonSide(p_187457_7_, enumhandside, p_187457_5_, p_187457_6_);
-            }
-        }
-        else
-        {
-            boolean flag1 = enumhandside == EnumHandSide.RIGHT;
-
-            if (p_187457_1_.isHandActive() && p_187457_1_.getItemInUseCount() > 0 && p_187457_1_.getActiveHand() == p_187457_4_)
-            {
-                int j = flag1 ? 1 : -1;
-
-                switch (p_187457_6_.getItemUseAction())
-                {
-                    case NONE:
-                        this.transformSideFirstPerson(enumhandside, p_187457_7_);
-                        break;
-
-                    case EAT:
-                    case DRINK:
-                        this.transformEatFirstPerson(p_187457_2_, enumhandside, p_187457_6_);
-                        this.transformSideFirstPerson(enumhandside, p_187457_7_);
-                        break;
-
-                    case BLOCK:
-                        this.transformSideFirstPerson(enumhandside, p_187457_7_);
-                        break;
-
-                    case BOW:
-                        this.transformSideFirstPerson(enumhandside, p_187457_7_);
-                        GlStateManager.translate((float)j * -0.2785682F, 0.18344387F, 0.15731531F);
-                        GlStateManager.rotate(-13.935F, 1.0F, 0.0F, 0.0F);
-                        GlStateManager.rotate((float)j * 35.3F, 0.0F, 1.0F, 0.0F);
-                        GlStateManager.rotate((float)j * -9.785F, 0.0F, 0.0F, 1.0F);
-                        float f5 = (float)p_187457_6_.getMaxItemUseDuration() - ((float)this.mc.player.getItemInUseCount() - p_187457_2_ + 1.0F);
-                        float f6 = f5 / 20.0F;
-                        f6 = (f6 * f6 + f6 * 2.0F) / 3.0F;
-
-                        if (f6 > 1.0F)
-                        {
-                            f6 = 1.0F;
-                        }
-
-                        if (f6 > 0.1F)
-                        {
-                            float f7 = MathHelper.sin((f5 - 0.1F) * 1.3F);
-                            float f3 = f6 - 0.1F;
-                            float f4 = f7 * f3;
-                            GlStateManager.translate(f4 * 0.0F, f4 * 0.004F, f4 * 0.0F);
-                        }
-
-                        GlStateManager.translate(f6 * 0.0F, f6 * 0.0F, f6 * 0.04F);
-                        GlStateManager.scale(1.0F, 1.0F, 1.0F + f6 * 0.2F);
-                        GlStateManager.rotate((float)j * 45.0F, 0.0F, -1.0F, 0.0F);
-                }
-            }
-            else
-            {
-                float f = -0.4F * MathHelper.sin(MathHelper.sqrt(p_187457_5_) * (float)Math.PI);
-                float f1 = 0.2F * MathHelper.sin(MathHelper.sqrt(p_187457_5_) * ((float)Math.PI * 2F));
-                float f2 = -0.2F * MathHelper.sin(p_187457_5_ * (float)Math.PI);
-                int i = flag1 ? 1 : -1;
-                GlStateManager.translate((float)i * f, f1, f2);
-                this.transformSideFirstPerson(enumhandside, p_187457_7_);
-                this.transformFirstPerson(enumhandside, p_187457_5_);
-            }
-
-            this.renderItemSide(p_187457_1_, p_187457_6_, flag1 ? ItemCameraTransforms.TransformType.FIRST_PERSON_RIGHT_HAND : ItemCameraTransforms.TransformType.FIRST_PERSON_LEFT_HAND, !flag1);
-        }
-
-        GlStateManager.popMatrix();
+    	boolean mainHand = hand == EnumHand.MAIN_HAND;
+    	EnumHandSide enumhandside = mainHand ? player.getPrimaryHand() : player.getPrimaryHand().opposite();
+    	equippingprogress = getEquipProgress(hand, partialTicks);
+	    	//VIVE
+	    	//        if (itemstack == null)
+	    	//        {
+	    	//            if (mainHand && !player.isInvisible())
+	    	//            {
+	    	//                this.renderArmFirstPerson(equippingprogress, swingProgress, enumhandside);
+	    	//            }
+	    	//        }
+    	    		
+    		boolean shouldrenderhand = true;
+    	
+    		if(itemstack!=null){
+    			GlStateManager.pushMatrix();		
+    			boolean thing = false;
+
+    			if (itemstack.getItem() instanceof ItemMap)
+    			{
+    				if (mainHand && this.itemStackOffHand == null)
+    				{
+    					this.renderMapFirstPerson(bodyPitch, equippingprogress, swingProgress);
+    				}
+    				else
+    				{
+    					this.renderMapFirstPersonSide(equippingprogress, enumhandside, swingProgress, itemstack);
+    				}
+    			}
+    			else
+    			{
+    				boolean rightSide = enumhandside == EnumHandSide.RIGHT;
+    				int i = rightSide ? 1 : -1;
+
+    				if (player.isHandActive() && player.getItemInUseCount() > 0 && player.getActiveHand() == hand)
+    				{ //using animations
+    					int j = rightSide ? 1 : -1;
+
+    					switch (itemstack.getItemUseAction())
+    					{
+    					case NONE:
+    						this.transformSideFirstPerson(enumhandside, equippingprogress);
+    						break;
+
+    					case EAT:
+    					case DRINK:
+    						this.transformEatFirstPerson(partialTicks, enumhandside, itemstack);
+    						this.transformSideFirstPerson(enumhandside, equippingprogress);
+    						break;
+
+    					case BLOCK:
+							GlStateManager.scale(1.2, 1.2, 1.2);
+    						if(player.isActiveItemStackBlocking()){
+    							GlStateManager.rotate(i*90.0F, 0.0F, 1.0F, 0.0F);  
+    						} else{
+    							GlStateManager.rotate((1-equippingprogress)*i*90.0F, 0.0F, 1.0F, 0.0F);
+    						}
+
+    						this.transformSideFirstPerson(enumhandside, equippingprogress);
+    						break;
+
+    					case BOW:
+    						//	    					this.doEquipItemAnimation(enumhandside, equippingprogress);
+    						//	    					GlStateManager.translate((float)j * -0.2785682F, 0.18344387F, 0.15731531F);
+    						//	    					GlStateManager.rotate(-13.935F, 1.0F, 0.0F, 0.0F);
+    						//	    					GlStateManager.rotate((float)j * 35.3F, 0.0F, 1.0F, 0.0F);
+    						//	    					GlStateManager.rotate((float)j * -9.785F, 0.0F, 0.0F, 1.0F);
+    						//	    					float f5 = (float)itemstack.getMaxItemUseDuration() - ((float)this.mc.player.getItemInUseCount() - partialTicks + 1.0F);
+    						//	    					float f6 = f5 / 20.0F;
+    						//	    					f6 = (f6 * f6 + f6 * 2.0F) / 3.0F;
+    						//	
+    						//	    					if (f6 > 1.0F)
+    						//	    					{
+    						//	    						f6 = 1.0F;
+    						//	    					}
+    						//	
+    						//	    					if (f6 > 0.1F)
+    						//	    					{
+    						//	    						float f7 = MathHelper.sin((f5 - 0.1F) * 1.3F);
+    						//	    						float f3 = f6 - 0.1F;
+    						//	    						float f4 = f7 * f3;
+    						//	    						GlStateManager.translate(f4 * 0.0F, f4 * 0.004F, f4 * 0.0F);
+    						//	    					}
+    						//	
+    						//	    					GlStateManager.translate(f6 * 0.0F, f6 * 0.0F, f6 * 0.04F);
+    						//	    					GlStateManager.scale(1.0F, 1.0F, 1.0F + f6 * 0.2F);
+    						//	    					GlStateManager.rotate((float)j * 45.0F, 0.0F, -1.0F, 0.0F);
+    						break;
+    					default:
+    						break;
+    					}
+    				}
+
+    				{
+    					float f = -0.4F * MathHelper.sin(MathHelper.sqrt(swingProgress) * (float)Math.PI);
+    					float f1 = 0.2F * MathHelper.sin(MathHelper.sqrt(swingProgress) * ((float)Math.PI * 2F));
+    					float f2 = -0.2F * MathHelper.sin(swingProgress * (float)Math.PI);
+
+    					//GlStateManager.translate((float)i * f, f1, f2);
+    					this.transformSideFirstPerson(enumhandside, equippingprogress);
+
+    					if(player.swingingHand == hand)
+    						this.transformFirstPerson(enumhandside, swingProgress);	
+
+    					//VIVE manually adjust items based on type... no other choice :(
+
+    					Item item =  itemstack.getItem();
+
+    					boolean vive = MCOpenVR.isVive;
+
+    					if(item instanceof ItemBlock){
+
+    						if (this.itemRenderer.shouldRenderItemIn3D(itemstack)){
+    							GlStateManager.translate(0f, 0f, -0.1f);	
+    							GlStateManager.scale(0.2, 0.2, 0.2);
+    						}else if(((ItemBlock) item).getBlock() == Blocks.TORCH) {
+    							GlStateManager.translate(0f, 0.05f, -0.2f);		
+    							GlStateManager.scale(0.6, 0.6, 0.6);	
+    							GlStateManager.rotate(90.0F, 0.0F, 1.0F, 0.0F);
+    							GlStateManager.rotate(-75.0F, 0.0F, 0.0F, 1.0F);    
+    						}else{
+    							GlStateManager.translate(0f, 0f, -0.15f);		
+    							GlStateManager.scale(0.3, 0.3, 0.3);
+    							GlStateManager.rotate(-i*45.0F, 0.0F, 1.0F, 0.0F);   
+    						}
+    					} 
+    					else if(item instanceof ItemSword )
+    					{
+    						if(vive){
+    							GlStateManager.translate(0f, 0f, -0.2f);		
+    							GlStateManager.scale(0.6, 0.6, 0.6);	
+    							GlStateManager.rotate(-45F, 1.0F, 0.0F, 0.0F);
+    							GlStateManager.rotate(90.0F, 0.0F, 1.0F, 0.0F);      							
+    						} else {
+    							GlStateManager.translate(0f, 0.10f, -0.125f);		
+    							GlStateManager.scale(0.6, 0.6, 0.6);	
+    							GlStateManager.rotate(-45F + 39.4f, 1.0F, 0.0F, 0.0F);
+    							GlStateManager.rotate(90.0F, 0.0F, 1.0F, 0.0F);  
+    						}
+
+    					}
+    					else if(item instanceof ItemTool ||
+    							item instanceof ItemArrow ||
+    							item instanceof ItemHoe || 
+    							item instanceof ItemFishingRod || 
+    							item instanceof ItemCarrotOnAStick ||
+    							item instanceof ItemShears||
+    							item instanceof ItemFlintAndSteel)
+
+    					{
+
+    						if(mc.climbTracker.isClaws(itemstack) && mc.climbTracker.isClimbeyClimb()){
+
+    							GlStateManager.scale(0.3, 0.3, 0.3);
+    							GlStateManager.translate(-.025f, .12f, .25f);
+    							GlStateManager.rotate(90, 0, 0, 1);	
+
+    							if((mc.gameSettings.keyBindAttack.isKeyDown() && rightSide) ||
+    									((mc.climbTracker.isGrabbingLadder() || !mc.player.onGround) && mc.gameSettings.keyBindForward.isKeyDown() && !rightSide)) {
+    								GlStateManager.translate(0f, 0f, -.2f);	
+    							}
+
+    						}
+
+    						if(vive){
+    							GlStateManager.translate(0f, -.025f, -0.1f);		
+    							GlStateManager.scale(0.6, 0.6, 0.6);	
+    							if(item instanceof ItemCarrotOnAStick || item instanceof ItemFishingRod) {}
+    							else
+    								GlStateManager.rotate(180.0F, 0.0F, 0.0F, 1.0F);  
+    							GlStateManager.rotate(-45F, 1.0F, 0.0F, 0.0F);
+    							GlStateManager.rotate(90.0F, 0.0F, 1.0F, 0.0F);
+    						} else {
+    							GlStateManager.translate(0f, 0.035, -0.1f);		
+    							GlStateManager.scale(0.6, 0.6, 0.6);	
+    							if(item instanceof ItemCarrotOnAStick || item instanceof ItemFishingRod) {
+    								GlStateManager.rotate(39.4f, 1.0F, 0.0F, 0.0F);
+    							}
+    							else
+    								GlStateManager.rotate(180.0F, 0.0F, 0.0F, 1.0F);  
+    							GlStateManager.rotate(-45F - 39.4f, 1.0F, 0.0F, 0.0F);
+    							GlStateManager.rotate(90.0F, 0.0F, 1.0F, 0.0F);
+    						}
+
+
+    					}
+    					else if(item instanceof ItemShield){
+    						GlStateManager.scale(0.4, 0.4, 0.4);
+    						GlStateManager.rotate(i*90.0F, 0.0F, 1.0F, 0.0F);  
+    						GlStateManager.translate(.5,0.5,.6);
+    					}
+    					else if(item instanceof ItemBow){
+    						//shouldrenderhand = false;
+    						GlStateManager.scale(1.0f, 1.0f, 1.0f);
+    						shouldrenderhand = false;
+    						if(mc.bowTracker.isDrawing){ //here there be dragons
+
+    							int c = 0;
+    							if (mc.vrSettings.vrReverseShootingEye) c = 1;
+
+    							Vec3d aim = mc.bowTracker.getAimVector(); 
+    							Vec3d a = new Vec3d(aim.xCoord, aim.yCoord, aim.zCoord);
+    							//a.rotateAroundY(-mc.vrSettings.vrWorldRotation);
+    							Vector3f aimCopy = new Vector3f((float)a.xCoord,(float) a.yCoord, (float)a.zCoord);
+
+    							//Matrix4f left = mc.lookaimController.getAimRotation(1);
+
+    							Vec3d lup = mc.vrPlayer.getCustomHandVector(1,  new Vec3d(0, -1, 0));
+    							Vector3f current = new Vector3f((float)lup.xCoord, (float)lup.yCoord, (float)lup.zCoord);
+    							Vec3d lback = mc.vrPlayer.getCustomHandVector(1,  new Vec3d(0, 0, -1));
+
+    							Vector3f currentfore =  new Vector3f((float)lback.xCoord, (float)lback.yCoord, (float)lback.zCoord);
+
+    							Vector3f v = aimCopy.cross(current);
+    							double d = 180 / Math.PI * Math.acos(aimCopy.dot(current));
+
+    							float pitch = (float)Math.toDegrees(Math.asin(aimCopy.y/aimCopy.length()));
+    							float yaw = (float)Math.toDegrees(Math.atan2(aimCopy.x, aimCopy.z));     
+
+    							Vector3f up = new Vector3f(0,1,0);
+
+    							Vector3f pAim2 = new Vector3f(0,0,0);
+
+    							aimCopy.y = 0 ; // we want the normal to a aiming plane, but vertical.
+
+    							float porjaim = currentfore.dot(aimCopy); //angle between controller up and aim, just for ortho check			    		        		
+    							if(porjaim !=0) { //check to make sure 	we arent holding the bow perfectly straight up.					
+    								pAim2 = aimCopy.divide(1/porjaim);	 //projection of l_controller_up onto aim vector ... why is there no multiply?		        	 
+    							}
+
+    							float dot =0;
+    							Vector3f proj = currentfore.subtract(pAim2).normalised(); //subtract to get projection of LCU onto vertical aim plane   
+
+    							dot = proj.dot(up);		//angle between our projection and straight up (the default bow render pos.)
+
+    							float dot2 = aimCopy.dot(proj.cross(up)); //angle sign test, negative is left roll
+
+    							float angle;
+
+    							if (dot2 < 0) 
+    								angle = -(float) Math.acos(dot);  	
+    							else angle = (float) Math.acos(dot); 
+
+    							float roll = (float) (180 / Math.PI * angle);     //calulate bow model roll.
+
+    							GlStateManager.rotate(yaw, 0.0F,1.0F, 0.0F);
+    							GlStateManager.rotate(-pitch, 1.0F, 0.0F, 0.0F);
+
+    							GlStateManager.rotate(-roll, 0.0F, 0.0F, 1.0F);  
+    							GlStateManager.rotate(90f, 1.0F, 0.0F, 0.0F);    
+    							//	GlStateManager.rotate(-180.0F, 0.0F, 0.0F, 1.0F);	
+
+    							if(mc.bowTracker.isCharged()){
+    								long t = Minecraft.getSystemTime() - mc.bowTracker.startDrawTime;
+    								GlStateManager.translate(0.003*Math.sin(t),0, 0);
+    							}
+    							GlStateManager.scale(1,mc.bowTracker.getDrawPercent()*0.15+1,1);
+
+
+    						} 
+    						else if(mc.vrSettings.seated){
+    							GlStateManager.rotate(90f, 1.0F, 0.0F, 0.0F);    
+    						}
+
+    						if(vive || mc.bowTracker.isDrawing){
+    							GlStateManager.translate(-0.012, 0.2, 00);
+    							GlStateManager.rotate(-45F, 1.0F, 0.0F, 0.0F);
+    						} else {
+    							GlStateManager.translate(-0.012, 0.17, .100);
+    							GlStateManager.rotate(-45F + 39.4f, 1.0F, 0.0F, 0.0F	);
+    						}
+
+    						GlStateManager.rotate(-90.0F, 0.0F, 1.0F, 0.0F);
+    						GlStateManager.rotate(90.0F, 0.0F, 0.0F, 1.0F);	
+
+    					}
+    					else { //NORMAL ITEMS
+    						GlStateManager.translate(0f, 0f, -0.1f);		
+    						GlStateManager.scale(0.3, 0.3, 0.3);
+    						GlStateManager.rotate(-i*45.0F, 0.0F, 1.0F, 0.0F);
+    					}
+    					z++;
+
+    				}
+
+    				this.itemRenderer.ismainhand = mainHand;
+    				this.itemRenderer.isfphand = true;
+
+    				//VIVE use 'NONE' transforms.
+    				if(!thing)
+    					this.renderItemSide(partialTicks,player, itemstack, rightSide ? ItemCameraTransforms.TransformType.NONE : ItemCameraTransforms.TransformType.NONE, !rightSide);
+    				else
+    					this.renderItemSide(partialTicks,player, itemstack, rightSide ? ItemCameraTransforms.TransformType.THIRD_PERSON_RIGHT_HAND : ItemCameraTransforms.TransformType.THIRD_PERSON_LEFT_HAND, !rightSide);
+
+    				this.itemRenderer.ismainhand = false;
+    				this.itemRenderer.isfphand = false;
+
+    			}
+    			GlStateManager.popMatrix();	
+    		}
+    		if(mc.player.isSneaking()) GlStateManager.color(1, 1, 1, 0.5f);
+    		
+    		if(mc.currentPass ==renderPass.Third && mc.vrSettings.mixedRealityRenderHands == false) 
+    			shouldrenderhand = false;
+    		
+	    	if (shouldrenderhand && !player.isInvisible())
+	    	{
+			    GlStateManager.tryBlendFuncSeparate(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO);
+			    this.renderArmFirstPerson(equippingprogress, player.swingingHand == hand ? swingProgress : 0, enumhandside);
+		    }
+	    	
+	    	GlStateManager.color(1, 1, 1, 1);
+	    	
     }
-
+    int z = 0;
     /**
      * Renders the overlays.
      */
     public void renderOverlays(float partialTicks)
     {
+    	inportal = false;
+    	inwater = false;
+    	inblock = false;
+    	onfire = false;
+    	
         GlStateManager.disableAlpha();
-
-        if (this.mc.player.isEntityInsideOpaqueBlock())
+        Vec3d pos = mc.entityRenderer.getEyeRenderPos(mc.currentPass);
+        if (isInsideOpaqueBlock(pos.add(mc.roomScale.getHMDDir_World().scale(0.05)), true))
         {
-            IBlockState iblockstate = this.mc.world.getBlockState(new BlockPos(this.mc.player));
-            BlockPos blockpos = new BlockPos(this.mc.player);
-            EntityPlayer entityplayer = this.mc.player;
-
-            for (int i = 0; i < 8; ++i)
-            {
-                double d0 = entityplayer.posX + (double)(((float)((i >> 0) % 2) - 0.5F) * entityplayer.width * 0.8F);
-                double d1 = entityplayer.posY + (double)(((float)((i >> 1) % 2) - 0.5F) * 0.1F);
-                double d2 = entityplayer.posZ + (double)(((float)((i >> 2) % 2) - 0.5F) * entityplayer.width * 0.8F);
-                BlockPos blockpos1 = new BlockPos(d0, d1 + (double)entityplayer.getEyeHeight(), d2);
-                IBlockState iblockstate1 = this.mc.world.getBlockState(blockpos1);
-
-                if (iblockstate1.causesSuffocation())
-                {
-                    iblockstate = iblockstate1;
-                    blockpos = blockpos1;
-                }
-            }
-
-            if (iblockstate.getRenderType() != EnumBlockRenderType.INVISIBLE)
-            {
-                Object object = Reflector.getFieldValue(Reflector.RenderBlockOverlayEvent_OverlayType_BLOCK);
-
-                if (!Reflector.callBoolean(Reflector.ForgeEventFactory_renderBlockOverlay, new Object[] {this.mc.player, Float.valueOf(partialTicks), object, iblockstate, blockpos}))
-                {
-                    this.renderBlockInHand(partialTicks, this.mc.getBlockRendererDispatcher().getBlockModelShapes().getTexture(iblockstate));
-                }
-            }
+              //  this.renderBlockInHand(partialTicks, this.mc.getBlockRendererDispatcher().getBlockModelShapes().getTexture(iblockstate));
+            	inblock = true;
         }
 
         if (!this.mc.player.isSpectator())
         {
-            if (this.mc.player.isInsideOfMaterial(Material.WATER) && !Reflector.callBoolean(Reflector.ForgeEventFactory_renderWaterOverlay, new Object[] {this.mc.player, Float.valueOf(partialTicks)}))
+            if (isInsideOfMaterial(pos, Material.WATER) )
             {
-                this.renderWaterOverlayTexture(partialTicks);
+            	inwater = true;
+              //  this.renderWaterOverlayTexture(partialTicks);
             }
 
+            
             if (this.mc.player.isBurning() && !Reflector.callBoolean(Reflector.ForgeEventFactory_renderFireOverlay, new Object[] {this.mc.player, Float.valueOf(partialTicks)}))
             {
                 this.renderFireInFirstPerson(partialTicks);
+                onfire = true;
             }
         }
 
+		
+        if (!this.mc.player.isPotionActive(MobEffects.NAUSEA))
+        {
+            float f = this.mc.player.prevTimeInPortal + (this.mc.player.timeInPortal - this.mc.player.prevTimeInPortal) * partialTicks;
+
+            if (f > 0.0F)
+            {
+            	inportal = true;
+               // this.renderPortal(f, new ScaledResolution(mc));
+            }
+        }
+		
+                
+        GlStateManager.enableAlpha();
+    }
+    
+    public boolean inwater, inportal, inblock, onfire;
+    public float inBlock = 0;
+    
+    private void renderPortal(float timeInPortal, ScaledResolution scaledRes)
+    {
+        if (timeInPortal < 1.0F)
+        {
+            timeInPortal = timeInPortal * timeInPortal;
+            timeInPortal = timeInPortal * timeInPortal;
+            timeInPortal = timeInPortal * 0.8F + 0.2F;
+        }
+        GlStateManager.enableTexture2D();
+        GlStateManager.disableAlpha();
+        GlStateManager.disableDepth();
+        GlStateManager.enableBlend();
+        GlStateManager.depthMask(false);
+        GlStateManager.tryBlendFuncSeparate(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO);
+        GlStateManager.color(1.0F, 1.0F, 1.0F, timeInPortal);
+        System.out.println(timeInPortal);
+        this.mc.getTextureManager().bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);
+        TextureAtlasSprite textureatlassprite = this.mc.getBlockRendererDispatcher().getBlockModelShapes().getTexture(Blocks.PORTAL.getDefaultState());
+        Tessellator tessellator = Tessellator.getInstance();
+        VertexBuffer vertexbuffer = tessellator.getBuffer();
+        float f6 = textureatlassprite.getMinU();
+        float f7 = textureatlassprite.getMaxU();
+        float f8 = textureatlassprite.getMinV();
+        float f9 = textureatlassprite.getMaxV();
+        vertexbuffer.begin(7, DefaultVertexFormats.POSITION_TEX);
+        vertexbuffer.pos(-1.0D, -1.0D, -.6D).tex((double)( f6), (double)( f8)).endVertex();
+        vertexbuffer.pos(1.0D, -1.0D, -.6D).tex((double)(f7), (double)( f8)).endVertex();
+        vertexbuffer.pos(1.0D, 1.0D, -.6D).tex((double)(f7), (double)(f9)).endVertex();
+        vertexbuffer.pos(-1.0D, 1.0D, -.6D).tex((double)( f6), (double)(f9)).endVertex();
+        tessellator.draw();
+        GlStateManager.depthMask(true);
+        GlStateManager.enableDepth();
         GlStateManager.enableAlpha();
+        GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
     }
+    
+    public boolean isInsideOfMaterial(Vec3d pos, Material materialIn)
+    {
+    	BlockPos blockpos = new BlockPos(pos);
+    	IBlockState iblockstate = mc.world.getBlockState(blockpos);
+    	IBlockState iblockstateup = mc.world.getBlockState(blockpos.up());
+
+    	if (iblockstate.getMaterial() == materialIn)
+    	{
+    		float f = BlockLiquid.getLiquidHeightPercent(iblockstate.getBlock().getMetaFromState(iblockstate)) -0.11111111F;;
+    		if(iblockstateup.getMaterial() != materialIn && materialIn instanceof MaterialLiquid) f+=0.09F;
+    		
+    		//float f1 = (float)(blockpos.getY() + 1) - f;
+    		boolean flag = (pos.yCoord-blockpos.getY()) < (1-f);
+    		return flag;
+    	}
+    	else
+    	{
+    		return false;
+    	}
+    }
+    
+    
+    public boolean isInsideOpaqueBlock(Vec3d in, boolean set)
+    {
+
+    	if (mc.world == null) return false;
+    	BlockPos bp = new BlockPos(in);
+    	
+    	if(mc.world.getBlockState(bp).isFullyOpaque()) {
+    		inBlock = 1;
+    		return true;
+    	}
+    	
+    	if(!set) return false;
+    	inBlock = 0;    	
+    	Vec3d pos = in.addVector(0, 0, 0);
+    	float per = 0;
+    	float buffer = .07f;	
+    	
+    	if((pos.xCoord - Math.floor(pos.xCoord)) < buffer) 
+    	{
+    		per = (float) (pos.xCoord - Math.floor(pos.xCoord));
+        	inBlock = (buffer - per) / buffer; 
+    		if (mc.world.getBlockState(bp.west()).isFullyOpaque()) return true;
+    	}
+    	
+    	if(pos.xCoord - Math.floor(pos.xCoord) > 1-buffer){
+    		per = 1f - (float) (pos.xCoord - Math.floor(pos.xCoord));
+        	inBlock = (buffer - per) / buffer; 
+    		if (mc.world.getBlockState(bp.east()).isFullyOpaque()) return true;
+    	}
+    	
+    	if((pos.yCoord - Math.floor(pos.yCoord)) < buffer) 
+    	{
+    		per = (float) (pos.yCoord - Math.floor(pos.yCoord));
+        	inBlock = (buffer - per) / buffer; 
+    		if (mc.world.getBlockState(bp.down()).isFullyOpaque()) return true;
+    	} 
+    	
+    	if(pos.yCoord - Math.floor(pos.yCoord) > 1-buffer){
+    		per = 1f - (float) (pos.yCoord - Math.floor(pos.yCoord));
+        	inBlock = (buffer - per) / buffer; 
+    		if (mc.world.getBlockState(bp.up()).isFullyOpaque()) return true;
+    	}
+    	
+    	if((pos.zCoord - Math.floor(pos.zCoord)) < buffer) 
+    	{
+    		per = (float) (pos.zCoord - Math.floor(pos.zCoord));
+        	inBlock = (buffer - per) / buffer; 
+    		if (mc.world.getBlockState(bp.north()).isFullyOpaque()) return true;
+    	} 
+    	
+    	if(pos.zCoord - Math.floor(pos.zCoord) > 1-buffer){
+    		per = 1f - (float) (pos.zCoord - Math.floor(pos.zCoord));
+        	inBlock = (buffer - per) / buffer; 
+    		if (mc.world.getBlockState(bp.south()).isFullyOpaque()) return true;
+    	}
 
-    /**
+    	return false;
+    	
+    }
+
+
+     /**
      * Render the block in the player's hand
      */
     private void renderBlockInHand(float partialTicks, TextureAtlasSprite atlas)
     {
+    	GlStateManager.disableDepth();
         this.mc.getTextureManager().bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);
         Tessellator tessellator = Tessellator.getInstance();
         VertexBuffer vertexbuffer = tessellator.getBuffer();
         float f = 0.1F;
         GlStateManager.color(0.1F, 0.1F, 0.1F, 0.5F);
         GlStateManager.pushMatrix();
-        float f1 = -1.0F;
-        float f2 = 1.0F;
-        float f3 = -1.0F;
-        float f4 = 1.0F;
-        float f5 = -0.5F;
         float f6 = atlas.getMinU();
-        float f7 = atlas.getMaxU();
+        float f7 = mc.vrSettings.insideBlockSolidColor ? atlas.getMinU() : atlas.getMaxU();
         float f8 = atlas.getMinV();
-        float f9 = atlas.getMaxV();
+        float f9 = mc.vrSettings.insideBlockSolidColor ? atlas.getMinV() : atlas.getMaxV();
         vertexbuffer.begin(7, DefaultVertexFormats.POSITION_TEX);
         vertexbuffer.pos(-1.0D, -1.0D, -0.5D).tex((double)f7, (double)f9).endVertex();
         vertexbuffer.pos(1.0D, -1.0D, -0.5D).tex((double)f6, (double)f9).endVertex();
@@ -560,17 +971,14 @@
             VertexBuffer vertexbuffer = tessellator.getBuffer();
             float f = this.mc.player.getBrightness(partialTicks);
             GlStateManager.color(f, f, f, 0.5F);
+            GlStateManager.enableTexture2D();
             GlStateManager.enableBlend();
             GlStateManager.tryBlendFuncSeparate(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO);
+            GlStateManager.disableDepth();
             GlStateManager.pushMatrix();
-            float f1 = 4.0F;
-            float f2 = -1.0F;
-            float f3 = 1.0F;
-            float f4 = -1.0F;
-            float f5 = 1.0F;
-            float f6 = -0.5F;
-            float f7 = -this.mc.player.rotationYaw / 64.0F;
-            float f8 = this.mc.player.rotationPitch / 64.0F;
+            //VIVE INFINITY!
+            float f7 = 0;//-this.mc.player.rotationYaw / 64.0F;
+            float f8 = 0;//this.mc.player.rotationPitch / 64.0F;
             vertexbuffer.begin(7, DefaultVertexFormats.POSITION_TEX);
             vertexbuffer.pos(-1.0D, -1.0D, -0.5D).tex((double)(4.0F + f7), (double)(4.0F + f8)).endVertex();
             vertexbuffer.pos(1.0D, -1.0D, -0.5D).tex((double)(0.0F + f7), (double)(4.0F + f8)).endVertex();
